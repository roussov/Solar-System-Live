{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { Component, HostListener } from '@angular/core';\nimport { interval, startWith, switchMap } from 'rxjs';\nlet SolarSystemComponent = class SolarSystemComponent {\n  constructor(planetService, ephemerisService) {\n    this.planetService = planetService;\n    this.ephemerisService = ephemerisService;\n    /**\n     * Métadonnées des 8 planètes (rayon, masse, demi-grand axe…).\n     * Fournies par PlanetService (valeurs physiques “moyennes”).\n     */\n    this.planets = [];\n    /**\n     * Planète actuellement sélectionnée (pour affichage dans PlanetInfoPanel).\n     */\n    this.selectedPlanet = null;\n    /**\n     * Données projetées sur l’écran (positions en pixels) dérivées\n     * des éphémérides réelles fournies par le backend.\n     */\n    this.displayPlanets = [];\n    /**\n     * Dimensions logiques du SVG (viewBox).\n     * Elles peuvent être ajustées sur resize pour rester responsives.\n     */\n    this.width = 800;\n    this.height = 800;\n    this.centerX = this.width / 2;\n    this.centerY = this.height / 2;\n    /**\n     * Mode de vue : 2D (vue du dessus) ou 3D (projection oblique).\n     * Ne modifie que la projection, pas les coordonnées physiques (X,Y,Z).\n     */\n    this.viewMode = '2d';\n    /**\n     * Timelapse : décalage temporel (en jours) appliqué aux éphémérides reçues.\n     * Un slider permet d’avancer/reculer d’un an, avec des pas jour/semaine/mois.\n     */\n    this.timeOffsetDays = 0;\n    this.maxTimeOffsetDays = 365;\n    this.timeStepDays = 1;\n    /**\n     * Options d’affichage avancées en vue 3D.\n     */\n    this.showOrbitalPlanes = true;\n    this.showPlanetAxes = true;\n    this.showShadows = true;\n    /**\n     * Angle de caméra utilisé en projection 3D (rotation dans le plan Y–Z).\n     */\n    this.cameraAngleRad = Math.PI / 6; // ≈ 30°\n    /**\n     * Longueur (en pixels) correspondant à 1 UA dans l’échelle radiale compressée.\n     * Affichée dans la barre d’échelle.\n     */\n    this.oneAuPixels = 0;\n    /**\n     * Valeur max du demi-grand axe (en UA) parmi les planètes.\n     * Sert de référence pour compresser l’échelle radiale (Neptune ~ max).\n     */\n    this.maxSemiMajorAxisAu = 30.1; // valeur par défaut, réajustée en ngOnInit\n    /**\n     * Dernier snapshot d’éphémérides reçu (positions réelles).\n     * Permet de recalculer l’affichage sur changement de mode ou resize\n     * sans réinterroger le backend.\n     */\n    this.lastSnapshot = null;\n    /**\n     * Indicateur de chargement (optionnel, au cas où tu veux l’exploiter dans le template).\n     */\n    this.isLoading = false;\n    /**\n     * Message d’erreur éventuel lors de l’appel au backend.\n     */\n    this.errorMessage = null;\n    /**\n     * Timestamp de la dernière mise à jour (vient du backend).\n     */\n    this.lastUpdateTimestamp = null;\n  }\n  // ---------------------------------------------------------------------------\n  // Cycle de vie\n  // ---------------------------------------------------------------------------\n  ngOnInit() {\n    this.planets = this.planetService.getPlanets();\n    // Détermine le plus grand demi-grand axe pour l’échelle\n    this.maxSemiMajorAxisAu = this.planets.reduce((max, p) => p.semiMajorAxisAU > max ? p.semiMajorAxisAU : max, 0) || 30.1;\n    // Initialisation des dimensions (responsive basique)\n    this.updateDimensionsFromWindow();\n    this.oneAuPixels = this.distanceToPixels(1);\n    // Mise à jour périodique des éphémérides (toutes les 60 s, avec un tir initial)\n    this.ephemerisSub = interval(60_000).pipe(startWith(0), switchMap(() => {\n      this.isLoading = true;\n      this.errorMessage = null;\n      return this.ephemerisService.getCurrentPlanetPositions();\n    })).subscribe({\n      next: snapshot => {\n        this.isLoading = false;\n        this.lastSnapshot = snapshot;\n        this.lastUpdateTimestamp = snapshot.timestamp || new Date().toISOString();\n        this.updateDisplayFromSnapshot(snapshot);\n      },\n      error: err => {\n        this.isLoading = false;\n        console.error('Erreur éphémérides:', err);\n        this.errorMessage = 'Erreur lors de la récupération des positions réelles des planètes.';\n      }\n    });\n  }\n  ngOnDestroy() {\n    this.ephemerisSub?.unsubscribe();\n  }\n  // ---------------------------------------------------------------------------\n  // Gestion de la fenêtre (responsivité)\n  // ---------------------------------------------------------------------------\n  onWindowResize() {\n    this.updateDimensionsFromWindow();\n    this.oneAuPixels = this.distanceToPixels(1);\n    // Si on a déjà des données d’éphémérides, on recalcule les positions\n    if (this.lastSnapshot) {\n      this.updateDisplayFromSnapshot(this.lastSnapshot);\n    }\n  }\n  /**\n   * Ajuste la largeur/hauteur du SVG en fonction de la taille de la fenêtre,\n   * en gardant un canvas carré centré et une marge raisonnable.\n   */\n  updateDimensionsFromWindow() {\n    const viewportWidth = window.innerWidth || 1024;\n    const maxSvg = 800;\n    // Petite marge latérale pour ne pas coller au bord de la fenêtre\n    const targetWidth = Math.min(viewportWidth - 64, maxSvg);\n    this.width = targetWidth > 320 ? targetWidth : 320;\n    this.height = this.width; // carré\n    this.centerX = this.width / 2;\n    this.centerY = this.height / 2;\n  }\n  // ---------------------------------------------------------------------------\n  // Échelle & projection\n  // ---------------------------------------------------------------------------\n  /**\n   * Conversion d’une distance en UA vers une distance en pixels,\n   * en utilisant une compression radiale (sqrt) pour garder les planètes\n   * externes visibles dans le même cadre.\n   */\n  distanceToPixels(au) {\n    if (au <= 0) {\n      return 0;\n    }\n    const maxRadiusPx = Math.min(this.width, this.height) / 2 - 40;\n    const maxAu = this.maxSemiMajorAxisAu || 30.1;\n    // Compression radiale : sqrt(au / maxAu) * rayon_max\n    const normalized = Math.sqrt(au / maxAu);\n    return normalized * maxRadiusPx;\n  }\n  /**\n   * Rayon visuel des planètes en pixels (tres compressé pour les géantes).\n   * Ici, on reste arbitraire sur le \"style\", mais toujours déterministe.\n   */\n  planetRadiusToPixels(planet) {\n    const base = 4;\n    const scale = 0.0005;\n    return base + planet.radiusKm * scale;\n  }\n  /**\n   * Rayon visuel des orbites, basé directement sur le demi-grand axe en UA.\n   */\n  getOrbitRadiusPx(planet) {\n    return this.distanceToPixels(planet.semiMajorAxisAU);\n  }\n  /**\n   * Changement de mode de vue (2D vs 3D).\n   * On ne change que la projection, pas les données physiques.\n   */\n  setViewMode(mode) {\n    if (this.viewMode === mode) {\n      return;\n    }\n    this.viewMode = mode;\n    // Si on dispose déjà d’un snapshot, on recalcule l’affichage\n    if (this.lastSnapshot) {\n      this.updateDisplayFromSnapshot(this.lastSnapshot);\n    }\n  }\n  /**\n   * Ajuste le pas du slider (1j / 7j / 30j).\n   */\n  setTimeStep(days) {\n    this.timeStepDays = days;\n  }\n  /**\n   * Mise à jour du décalage temporel via le slider.\n   */\n  onTimeOffsetChange(event) {\n    const value = Number(event.target.value);\n    this.timeOffsetDays = Number.isFinite(value) ? value : 0;\n    this.refreshDisplay();\n  }\n  /**\n   * Réinitialise le décalage temporel (retour à l’horodatage réel).\n   */\n  resetTimeOffset() {\n    this.timeOffsetDays = 0;\n    this.refreshDisplay();\n  }\n  // ---------------------------------------------------------------------------\n  // Rendu à partir des éphémérides réelles\n  // ---------------------------------------------------------------------------\n  /**\n   * Met à jour les positions affichées à partir d’un snapshot d’éphémérides.\n   * Les coordonnées (x, y, z) sont interprétées comme héliocentriques en UA.\n   */\n  updateDisplayFromSnapshot(snapshot) {\n    if (!snapshot || !snapshot.bodies || snapshot.bodies.length === 0) {\n      this.displayPlanets = [];\n      return;\n    }\n    const positionsByName = new Map();\n    for (const body of snapshot.bodies) {\n      positionsByName.set(body.name, body);\n    }\n    const display = [];\n    for (const planet of this.planets) {\n      const pos = positionsByName.get(planet.name);\n      if (!pos) {\n        continue;\n      }\n      const baseRAu = Math.sqrt(pos.x_au * pos.x_au + pos.y_au * pos.y_au + pos.z_au * pos.z_au) || planet.semiMajorAxisAU || 1e-6;\n      // Approximation orbitale simple : on tourne le vecteur autour du Soleil\n      // en fonction de la période orbitale (pas d’excentricité ni d’AN/Vp).\n      const orbitalPeriod = planet.orbitalPeriodDays || 365.25;\n      const baseAngle = Math.atan2(pos.y_au, pos.x_au);\n      const deltaAngle = 2 * Math.PI * this.timeOffsetDays / orbitalPeriod;\n      const targetAngle = baseAngle + deltaAngle;\n      // Rayon utilisé pour la projection (distance actuelle ou semi-major)\n      const orbitalRadiusAu = Math.max(baseRAu, planet.semiMajorAxisAU || baseRAu);\n      let xOrbit = orbitalRadiusAu * Math.cos(targetAngle);\n      let yOrbit = orbitalRadiusAu * Math.sin(targetAngle);\n      let zOrbit = pos.z_au; // on préserve le relief actuel\n      // Inclinaison orbitale (ajustement léger du relief en 3D)\n      const incRad = (planet.inclinationDeg || 0) * Math.PI / 180;\n      zOrbit += orbitalRadiusAu * Math.sin(incRad) * Math.sin(targetAngle);\n      const rAu = Math.sqrt(xOrbit * xOrbit + yOrbit * yOrbit + zOrbit * zOrbit) || 1e-6;\n      const rPx = this.distanceToPixels(rAu);\n      const scale = rPx / rAu || 1;\n      const planetRadiusPx = this.planetRadiusToPixels(planet);\n      let xScreen;\n      let yScreen;\n      if (this.viewMode === '2d') {\n        // Vue du dessus : projection dans le plan (x, y)\n        const angle = Math.atan2(pos.y_au, pos.x_au);\n        xScreen = this.centerX + rPx * Math.cos(angle);\n        yScreen = this.centerY + rPx * Math.sin(angle);\n      } else {\n        // Vue pseudo-3D : même position physique (x, y, z),\n        // projection oblique autour de l’axe X.\n        const projected = this.project3dPoint(xOrbit, yOrbit, zOrbit, scale);\n        xScreen = projected.x;\n        yScreen = projected.y;\n      }\n      // Axe planétaire (vue 3D uniquement)\n      let axis;\n      if (this.viewMode === '3d' && this.showPlanetAxes) {\n        const tiltRad = (planet.axialTiltDeg || 0) * Math.PI / 180;\n        const axisHalfPx = planetRadiusPx * 1.5;\n        const axisHalfAu = axisHalfPx / (scale || 1);\n        const axisY = Math.sin(tiltRad) * axisHalfAu;\n        const axisZ = Math.cos(tiltRad) * axisHalfAu;\n        const start = this.project3dPoint(xOrbit, yOrbit - axisY, zOrbit - axisZ, scale);\n        const end = this.project3dPoint(xOrbit, yOrbit + axisY, zOrbit + axisZ, scale);\n        axis = {\n          x1: start.x,\n          y1: start.y,\n          x2: end.x,\n          y2: end.y\n        };\n      }\n      // Ombre portée simple (ellipse aplatie sous la planète)\n      let shadow;\n      if (this.viewMode === '3d' && this.showShadows) {\n        shadow = {\n          cx: xScreen,\n          cy: yScreen + planetRadiusPx * 0.6,\n          rx: planetRadiusPx * 1.4,\n          ry: planetRadiusPx * 0.65\n        };\n      }\n      display.push({\n        planet,\n        x: xScreen,\n        y: yScreen,\n        rAu,\n        isSelected: !!this.selectedPlanet && this.selectedPlanet.name === planet.name,\n        axis,\n        shadow\n      });\n    }\n    this.displayPlanets = display;\n  }\n  /**\n   * Bascule des options d’affichage en vue 3D.\n   */\n  onToggleOrbitPlanes(checked) {\n    this.showOrbitalPlanes = checked;\n    this.refreshDisplay();\n  }\n  onTogglePlanetAxes(checked) {\n    this.showPlanetAxes = checked;\n    this.refreshDisplay();\n  }\n  onToggleShadows(checked) {\n    this.showShadows = checked;\n    this.refreshDisplay();\n  }\n  /**\n   * Recalcule l’affichage depuis le dernier snapshot si disponible.\n   */\n  refreshDisplay() {\n    if (this.lastSnapshot) {\n      this.updateDisplayFromSnapshot(this.lastSnapshot);\n    }\n  }\n  /**\n   * Compression visuelle des plans orbitaux en vue 3D.\n   */\n  orbitPlaneCompression(planet) {\n    const incRad = (planet.inclinationDeg || 0) * Math.PI / 180;\n    const base = Math.cos(this.cameraAngleRad);\n    const tilt = Math.cos(incRad);\n    return Math.max(0.2, base * tilt);\n  }\n  /**\n   * Projection oblique d’un point 3D (en UA) vers l’écran (px).\n   */\n  project3dPoint(xAu, yAu, zAu, scale) {\n    const x = xAu * scale;\n    const y = yAu * scale;\n    const z = zAu * scale;\n    const phi = this.cameraAngleRad;\n    const yProj = y * Math.cos(phi) - z * Math.sin(phi);\n    return {\n      x: this.centerX + x,\n      y: this.centerY + yProj\n    };\n  }\n  // ---------------------------------------------------------------------------\n  // Interaction utilisateur\n  // ---------------------------------------------------------------------------\n  /**\n   * Gestion du clic sur une planète dans le SVG.\n   */\n  onPlanetClick(planet) {\n    this.selectedPlanet = planet;\n    // Marque visuellement la planète sélectionnée (si tu veux exploiter .selected en CSS)\n    this.displayPlanets = this.displayPlanets.map(dp => ({\n      ...dp,\n      isSelected: dp.planet.name === planet.name\n    }));\n  }\n  /**\n   * Gestion de la fermeture du panneau d’info.\n   */\n  onCloseInfo() {\n    this.selectedPlanet = null;\n    // Nettoie le flag de sélection visuelle\n    this.displayPlanets = this.displayPlanets.map(dp => ({\n      ...dp,\n      isSelected: false\n    }));\n  }\n};\n__decorate([HostListener('window:resize')], SolarSystemComponent.prototype, \"onWindowResize\", null);\nSolarSystemComponent = __decorate([Component({\n  selector: 'app-solar-system',\n  templateUrl: './solar-system.component.html',\n  styleUrls: ['./solar-system.component.css']\n})], SolarSystemComponent);\nexport { SolarSystemComponent };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}